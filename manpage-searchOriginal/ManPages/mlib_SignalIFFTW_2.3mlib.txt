<beginning of page>
mlib_SignalIFFTW_2, mlib_SignalIFFTW_2_S16_S16_Mod, mlib_SignalIFFTW_2_S16C_S16C_Mod, mlib_Sig<hy>
nalIFFTW_2_S16_S16C_Mod, mlib_SignalIFFTW_2_S16_Mod, mlib_SignalIFFTW_2_S16C_Mod, mlib_Sig<hy>
nalIFFTW_2_F32_F32, mlib_SignalIFFTW_2_F32C_F32C, mlib_SignalIFFTW_2_F32_F32C, mlib_Sig<hy>
nalIFFTW_2_F32, mlib_SignalIFFTW_2_F32C <-> signal Inverse Fast Fourier Transform with windowing (IFFTW)
cc [ flag... ] file... -lmlib [ library... ]
#include <mlib.h>
mlib_status mlib_SignalIFFTW_2_S16_S16_Mod(mlib_s16 *dstr,
 mlib_s16 *dsti,
 const mlib_s16 *srcr, const mlib_s16 *srci, const mlib_s16 *window,
 mlib_s32 order);
mlib_status mlib_SignalIFFTW_2_S16C_S16C_Mod(mlib_s16 *dstc,
 const mlib_s16 *srcc,
 const mlib_s16 *window, mlib_s32 order);
mlib_status mlib_SignalIFFTW_2_S16_S16C_Mod(mlib_s16 *dstr,
 const mlib_s16 *srcc,
 const mlib_s16 *window, mlib_s32 order);
mlib_status mlib_SignalIFFTW_2_S16_Mod(mlib_s16 *srcdstr,
 mlib_s16 *srcdsti,
 const mlib_s16 *window, mlib_s32 order);
mlib_status mlib_SignalIFFTW_2_S16C_Mod(mlib_s16 *srcdstc,
 const mlib_s16 *window,
 mlib_s32 order);
mlib_status mlib_SignalIFFTW_2_F32_F32(mlib_f32 *dstr,
 mlib_f32 *dsti,
 const mlib_f32 *srcr, const mlib_f32 *srci, const mlib_f32 *window,
 mlib_s32 order);
mlib_status mlib_SignalIFFTW_2_F32C_F32C(mlib_f32 *dstc,
 const mlib_f32 *srcc,
 const mlib_f32 *window, mlib_s32 order);
mlib_status mlib_SignalIFFTW_2_F32_F32C(mlib_f32 *dstr,
 const mlib_f32 *srcc,
 const mlib_f32 *window, mlib_s32 order);
mlib_status mlib_SignalIFFTW_2_F32(mlib_f32 *srcdstr,
 mlib_f32 *srcdsti,
 const mlib_f32 *window, mlib_s32 order);
mlib_status mlib_SignalIFFTW_2_F32C(mlib_f32 *srcdstc,
 const mlib_f32 *window,
 mlib_s32 order);
Each of the functions in this group performs Inverse Fast Fourier Transform with windowing (IFFTW).
The FFTW functions use the following equation:
  1 N-1
 dst[k] = ---- SUM {src[n] * window[n] * exp(-j2*PI*n*k/N)}
  C1 n=0
and the IFFTW functions use the following equation:
  1 N-1
 dst[n] = ---- SUM {src[k] * window[k] * exp(j2*PI*n*k/N)}
  C2 k=0
<beginning of page>
where
 k = 0, 1, ..., (N - 1)
 n = 0, 1, ..., (N - 1)
 N = 2**order
The signal FFTW/IFFTW functions can be categorized into four groups according to the ScaleMode in the function
names in the following form:
 mlib_Signal[FFTW|IFFTW]_ScaleMode_OutType_InType_OpMode()
 mlib_Signal[FFTW|IFFTW]_ScaleMode_DataType_OpMode()
The scaling factors C1 and C2 used in the equations are defined as follows: <bu> For ScaleMode = 1, C1 = 1 and C2 =
2**order. <bu> For ScaleMode = 2, C1 = 2**order and C2 = 1. <bu> For ScaleMode = 3, C1 = C2 = 2**(order/2) when
order is even, or C1 = 2**((order+1)/2) and C2 = 2**((order-1)/2) when order is odd. <bu> For ScaleMode = 4, C1
= 2**P and C2 = 2**Q, where P and Q are adaptive scaling factors and are generated by the functions.
For functions with only real parts for the source signal, the imaginary parts are assumed to be all zero. For functions
with only real parts for the destination signal, the imaginary parts are discarded. The functions with only one data
type in their names perform the operation in place.
Each function takes some of the following arguments:
dstr Destination signal array that contains the real parts.
dsti Destination signal array that contains the imaginary parts.
srcr Source signal array that contains the real parts.
srci Source signal array that contains the imaginary parts.
dstc Complex destination signal array. dstc[2*i] contains the real parts, and dstc[2*i+1] contains the imaginary
parts.
srcc Complex source signal array. srcc[2*i] contains the real parts, and srcc[2*i+1] contains the imaginary parts.
srcdstr Source and destination signal array that contains the real parts.
srcdsti Source and destination signal array that contains the imaginary parts.
srcdstc Complex source and destination signal array. srcdstc[2*i] contains the real parts, and srcdstc[2*i+1] con<hy>
tains the imaginary parts.
window Window coefficient array with 2**order real elements. The window coefficients are in Q15 format for the
S16 data type, or in float format for the F32 data type.
order Order of the transformation. The base-2 logarithm of the number of data samples.
Each function returns MLIB_SUCCESS if successful. Otherwise it returns MLIB_FAILURE.
See attributes(5) for descriptions of the following attributes:
<beginning of page>
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
mlib_SignalFFTW_1(3MLIB), mlib_SignalFFTW_2(3MLIB), mlib_SignalFFTW_3(3MLIB), mlib_Sig<hy>
nalFFTW_4(3MLIB), mlib_SignalIFFTW_1(3MLIB), mlib_SignalIFFTW_3(3MLIB), mlib_Sig<hy>
nalIFFTW_4(3MLIB), attributes(5)
