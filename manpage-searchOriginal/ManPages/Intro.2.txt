<beginning of page>
Intro, intro <-> introduction to system calls and error numbers
#include <errno.h>
A system call is a C library function that requests a service from the system, such as getting the time of day. This re<hy>
quest is performed in the kernel. The library interface executes a trap into the kernel, which actually executes the
system call code.
Most system calls return one or more error conditions. An error condition is indicated by an otherwise impossible re<hy>
turn value. This is almost always <mi>1 or the null pointer; the individual descriptions specify the details. An error num<hy>
ber is also made available in the external variable errno, which is not cleared on successful calls, so it should be
tested only after an error has been indicated.
In the case of multithreaded applications, the -mt option must be specified on the command line at compilation time
(see threads(5)). When the -mt option is specified, errno becomes a macro that enables each thread to have its own
errno. This errno macro can be used on either side of the assignment as though it were a variable.
An error value listed as "will fail" describes a condition whose detection and reporting is mandatory for an imple<hy>
mentation that conforms to the Single UNIX Specification (SUS). An application can rely on this condition being
detected and reported. An error value listed as "may fail" describes a condition whose detection and reporting is op<hy>
tional for an implementation that conforms to the SUS. An application should not rely this condition being detected
and reported. An application that relies on such behavior cannot be assured to be portable across conforming imple<hy>
mentations. If more than one error occurs in processing a function call, any one of the possible errors might may be
returned, as the order of detection is undefined. See standards(5) for additional information regarding the Single
UNIX Specification.
Each system call description attempts to list all possible error numbers. The following is a complete list of the error
numbers and their names as defined in <errno.h>.
1 EPERM Lacking appropriate privileges
Typically this error indicates an attempt to modify a file in some way forbidden except to its owner or an appropri<hy>
ately privileged process. It is also returned for attempts by ordinary users to perform operations allowed only to pro<hy>
cesses with certain privileges.
The manual pages for individual functions document which privileges are needed to override the restriction.
2 ENOENT No such file or directory
A file name is specified and the file should exist but doesn't, or one of the directories in a path name does not exist.
3 ESRCH No such process, LWP, or thread
No process can be found in the system that corresponds to the specified PID, LWPID_t, or thread_t.
4 EINTR Interrupted system call
An asynchronous signal (such as interrupt or quit), which the user has elected to catch, occurred during a system ser<hy>
vice function. If execution is resumed after processing the signal, it will appear as if the interrupted function call re<hy>
turned this error condition.
In a multithreaded application, EINTR may be returned whenever another thread or LWP calls fork(2).
5 EIO I/O error
Some physical I/O error has occurred. This error may in some cases occur on a call following the one to which it ac<hy>
tually applies.
6 ENXIO No such device or address
I/O on a special file refers to a subdevice which does not exist, or exists beyond the limit of the device. It may also
<beginning of page>
occur when, for example, a tape drive is not on-line or no disk pack is loaded on a drive.
7 E2BIG Arg list too long
An argument list longer than ARG_MAX bytes is presented to a member of the exec family of functions (see ex<hy>
ec(2)). The argument list limit is the sum of the size of the argument list plus the size of the environment's exported
shell variables.
8 ENOEXEC Exec format error
A request is made to execute a file which, although it has the appropriate permissions, does not start with a valid for<hy>
mat (see a.out(4)).
9 EBADF Bad file number
Either a file descriptor refers to no open file, or a read(2) (respectively, write(2)) request is made to a file that is
open only for writing (respectively, reading).
10 ECHILD No child processes
A wait(3C) function call was executed by a process that had no existing or unwaited-for child processes.
11 EAGAIN No more processes, or no more LWPs
For example, the fork(2) function failed because the system's process table is full or the user is not allowed to create
any more processes, or a call failed because of insufficient memory or swap space.
12 ENOMEM Not enough space
During execution of brk() or sbrk() (see brk(2)), or one of the exec family of functions, a program asks for more
space than the system is able to supply. This is not a temporary condition; the maximum size is a system parameter.
On some architectures, the error may also occur if the arrangement of text, data, and stack segments requires too
many segmentation registers, or if there is not enough swap space during the fork(2) function.
13 EACCES Permission denied
An attempt was made to access a file in a way forbidden by the protection system.
The manual pages for individual functions document which privileges are needed to override the protection system.
14 EFAULT Bad address
The system encountered a hardware fault in attempting to use an argument of a routine. For example, errno poten<hy>
tially may be set to EFAULT any time a routine that takes a pointer argument is passed an invalid address, if the
system can detect the condition. Because systems will differ in their ability to reliably detect a bad address, on some
implementations passing a bad address to a routine will result in undefined behavior.
15 ENOTBLK Block device required
A non-block device or file was mentioned where a block device was required (for example, in a call to the mount(2)
function).
16 EBUSY Device busy
An attempt was made to mount a device that was already mounted or an attempt was made to unmount a device on
which there is an active file (open file, current directory, mounted-on file, active text segment). It will also occur if an
<beginning of page>
attempt is made to enable accounting when it is already enabled. The device or resource is currently unavailable.
EBUSY is also used by mutexes, semaphores, condition variables, and r/w locks, to indicate that a lock is held, and
by the processor control function P_ONLINE.
17 EEXIST File exists
An existing file was mentioned in an inappropriate context (for example, call to the link(2) function).
18 EXDEV Cross-device link
A hard link to a file on another device was attempted.
19 ENODEV No such device
An attempt was made to apply an inappropriate operation to a device (for example, read a write-only device).
20 ENOTDIR Not a directory
A non-directory was specified where a directory is required (for example, in a path prefix or as an argument to the
chdir(2) function).
21 EISDIR Is a directory
An attempt was made to write on a directory.
22 EINVAL Invalid argument
An invalid argument was specified (for example, unmounting a non-mounted device), mentioning an undefined sig<hy>
nal in a call to the signal(3C) or kill(2) function, or an unsupported operation related to extended attributes was at<hy>
tempted.
23 ENFILE File table overflow
The system file table is full (that is, SYS_OPEN files are open, and temporarily no more files can be opened).
24 EMFILE Too many open files
No process may have more than OPEN_MAX file descriptors open at a time.
25 ENOTTY Inappropriate ioctl for device
A call was made to the ioctl(2) function specifying a file that is not a special character device.
26 ETXTBSY Text file busy (obsolete)
An attempt was made to execute a pure-procedure program that is currently open for writing. Also an attempt to
open for writing or to remove a pure-procedure program that is being executed. (This message is obsolete.)
27 EFBIG File too large
The size of the file exceeded the limit specified by resource RLIMIT_FSIZEn; the file size exceeds the maximum
supported by the file system; or the file size exceeds the offset maximum of the file descriptor. See the File Descrip<hy>
tor subsection of the DEFINITIONS section below.
<beginning of page>
28 ENOSPC No space left on device
While writing an ordinary file or creating a directory entry, there is no free space left on the device. In the fcntl(2)
function, the setting or removing of record locks on a file cannot be accomplished because there are no more record
entries left on the system.
29 ESPIPE Illegal seek
A call to the lseek(2) function was issued to a pipe.
30 EROFS Read-only file system
An attempt to modify a file or directory was made on a device mounted read-only.
31 EMLINK Too many links
An attempt to make more than the maximum number of links, LINK_MAX, to a file.
32 EPIPE Broken pipe
A write on a pipe for which there is no process to read the data. This condition normally generates a signal; the error
is returned if the signal is ignored.
33 EDOM Math argument out of domain of function
The argument of a function in the math package (3M) is out of the domain of the function.
34 ERANGE Math result not representable
The value of a function in the math package (3M) is not representable within machine precision.
35 ENOMSG No message of desired type
An attempt was made to receive a message of a type that does not exist on the specified message queue (see msgr<hy>
cv(2)).
36 EIDRM Identifier removed
This error is returned to processes that resume execution due to the removal of an identifier from the file system's
name space (see msgctl(2), semctl(2), and shmctl(2)).
37 ECHRNG Channel number out of range
38 EL2NSYNC Level 2 not synchronized
39 EL3HLT Level 3 halted
40 EL3RST Level 3 reset
41 ELNRNG Link number out of range
<beginning of page>
42 EUNATCH Protocol driver not attached
43 ENOCSI No CSI structure available
44 EL2HLT Level 2 halted
45 EDEADLK Deadlock condition
A deadlock situation was detected and avoided. This error pertains to file and record locking, and also applies to mu<hy>
texes, semaphores, condition variables, and r/w locks.
46 ENOLCK No record locks available
There are no more locks available. The system lock table is full (see fcntl(2)).
47 ECANCELED Operation canceled
The associated asynchronous operation was canceled before completion.
48 ENOTSUP Not supported
This version of the system does not support this feature. Future versions of the system may provide support.
49 EDQUOT Disc quota exceeded
A write(2) to an ordinary file, the creation of a directory or symbolic link, or the creation of a directory entry failed
because the user's quota of disk blocks was exhausted, or the allocation of an inode for a newly created file failed
because the user's quota of inodes was exhausted.
58-59 Reserved
60 ENOSTR Device not a stream
A putmsg(2) or getmsg(2) call was attempted on a file descriptor that is not a STREAMS device.
61 ENODATA No data available
62 ETIME Timer expired
The timer set for a STREAMS ioctl(2) call has expired. The cause of this error is device-specific and could indicate
either a hardware or software failure, or perhaps a timeout value that is too short for the specific operation. The sta<hy>
tus of the ioctl() operation is indeterminate. This is also returned in the case of _lwp_cond_timedwait(2) or
cond_timedwait(3C).
63 ENOSR Out of stream resources
During a STREAMS open(2) call, either no STREAMS queues or no STREAMS head data structures were avail<hy>
able. This is a temporary condition; one may recover from it if other processes release resources.
65 ENOPKG Package not installed
This error occurs when users attempt to use a call from a package which has not been installed.
<beginning of page>
71 EPROTO Protocol error
Some protocol error occurred. This error is device-specific, but is generally not related to a hardware failure.
77 EBADMSG Not a data message
During a read(2), getmsg(2), or ioctl(2) I_RECVFD call to a STREAMS device, something has come to the head
of the queue that can not be processed. That something depends on the call:
read(): control information or passed file descriptor.
getmsg(): passed file descriptor.
ioctl(): control or data information.
78 ENAMETOOLONG File name too long
The length of the path argument exceeds PATH_MAX, or the length of a path component exceeds NAME_MAX
while _POSIX_NO_TRUNC is in effect; see limits.h(3HEAD).
79 EOVERFLOW Value too large for defined data type.
80 ENOTUNIQ Name not unique on network
Given log name not unique.
81 EBADFD File descriptor in bad state
Either a file descriptor refers to no open file or a read request was made to a file that is open only for writing.
82 EREMCHG Remote address changed
83 ELIBACC Cannot access a needed share library
Trying to exec an a.out that requires a static shared library and the static shared library does not exist or the user
does not have permission to use it.
84 ELIBBAD Accessing a corrupted shared library
Trying to exec an a.out that requires a static shared library (to be linked in) and exec could not load the static shared
library. The static shared library is probably corrupted.
85 ELIBSCN .lib section in a.out corrupted
Trying to exec an a.out that requires a static shared library (to be linked in) and there was erroneous data in the .lib
section of the a.out. The .lib section tells exec what static shared libraries are needed. The a.out is probably corrupt<hy>
ed.
86 ELIBMAX Attempting to link in more shared libraries than system limit
Trying to exec an a.out that requires more static shared libraries than is allowed on the current configuration of the
system. See System Administration Guide: IP Services
<beginning of page>
87 ELIBEXEC Cannot exec a shared library directly
Attempting to exec a shared library directly.
88 EILSEQ Error 88
Illegal byte sequence. Handle multiple characters as a single character.
89 ENOSYS Operation not applicable
90 ELOOP Number of symbolic links encountered during path name traversal exceeds MAXSYMLINKS
91 ESTART Restartable system call
Interrupted system call should be restarted.
92 ESTRPIPE If pipe/FIFO, don't sleep in stream head
Streams pipe error (not externally visible).
93 ENOTEMPTY Directory not empty
94 EUSERS Too many users
95 ENOTSOCK Socket operation on non-socket
96 EDESTADDRREQ Destination address required
A required address was omitted from an operation on a transport endpoint. Destination address required.
97 EMGSIZE Message too long
A message sent on a transport provider was larger than the internal message buffer or some other network limit.
98 EPROTOTYPE Protocol wrong type for socket
A protocol was specified that does not support the semantics of the socket type requested.
99 ENOPROTOOPT Protocol not available
A bad option or level was specified when getting or setting options for a protocol.
120 EPROTONOSUPPORT Protocol not supported
The protocol has not been configured into the system or no implementation for it exists.
121 ESOCKTNOSUPPORT Socket type not supported
The support for the socket type has not been configured into the system or no implementation for it exists.
<beginning of page>
122 EOPNOTSUPP Operation not supported on transport endpoint
For example, trying to accept a connection on a datagram transport endpoint.
123 EPFNOSUPPORT Protocol family not supported
The protocol family has not been configured into the system or no implementation for it exists. Used for the Internet
protocols.
124 EAFNOSUPPORT Address family not supported by protocol family
An address incompatible with the requested protocol was used.
125 EADDRINUSE Address already in use
User attempted to use an address already in use, and the protocol does not allow this.
126 EADDRNOTAVAIL Cannot assign requested address
Results from an attempt to create a transport endpoint with an address not on the current machine.
127 ENETDOWN Network is down
Operation encountered a dead network.
128 ENETUNREACH Network is unreachable
Operation was attempted to an unreachable network.
129 ENETRESET Network dropped connection because of reset
The host you were connected to crashed and rebooted.
130 ECONNABORTED Software caused connection abort
A connection abort was caused internal to your host machine.
131 ECONNRESET Connection reset by peer
A connection was forcibly closed by a peer. This normally results from a loss of the connection on the remote host
due to a timeout or a reboot.
132 ENOBUFS No buffer space available
An operation on a transport endpoint or pipe was not performed because the system lacked sufficient buffer space or
because a queue was full.
133 EISCONN Transport endpoint is already connected
A connect request was made on an already connected transport endpoint; or, a sendto(3SOCKET) or
sendmsg(3SOCKET) request on a connected transport endpoint specified a destination when already connected.
<beginning of page>
134 ENOTCONN Transport endpoint is not connected
A request to send or receive data was disallowed because the transport endpoint is not connected and (when sending
a datagram) no address was supplied.
143 ESHUTDOWN Cannot send after transport endpoint shutdown
A request to send data was disallowed because the transport endpoint has already been shut down.
144 ETOOMANYREFS Too many references: cannot splice
145 ETIMEDOUT Connection timed out
A connect(3SOCKET) or send(3SOCKET) request failed because the connected party did not properly respond af<hy>
ter a period of time; or a write(2) or fsync(3C) request failed because a file is on an NFS file system mounted with
the soft option.
146 ECONNREFUSED Connection refused
No connection could be made because the target machine actively refused it. This usually results from trying to con<hy>
nect to a service that is inactive on the remote host.
147 EHOSTDOWN Host is down
A transport provider operation failed because the destination host was down.
148 EHOSTUNREACH No route to host
A transport provider operation was attempted to an unreachable host.
149 EALREADY Operation already in progress
An operation was attempted on a non-blocking object that already had an operation in progress.
150 EINPROGRESS Operation now in progress
An operation that takes a long time to complete (such as a connect()) was attempted on a non-blocking object.
151 ESTALE Stale NFS file handle
Any process group that is not the foreground process group of a session that has established a connection with a
controlling terminal.
A session leader that established a connection to a controlling terminal.
A terminal that is associated with a session. Each session may have, at most, one controlling terminal associated
with it and a controlling terminal may be associated with only one session. Certain input sequences from the con<hy>
trolling terminal cause signals to be sent to process groups in the session associated with the controlling terminal;
see termio(7I).
Directories organize files into a hierarchical system where directories are the nodes in the hierarchy. A directory is a
file that catalogs the list of files, including directories (sub-directories), that are directly beneath it in the hierarchy.
Entries in a directory file are called links. A link associates a file identifier with a filename. By convention, a directo<hy>
ry contains at least two links, . (dot) and .. (dot-dot). The link called dot refers to the directory itself while dot-dot
refers to its parent directory. The root directory, which is the top-most node of the hierarchy, has itself as its parent
directory. The pathname of the root directory is / and the parent directory of the root directory is /.
<beginning of page>
In a stream, the direction from stream head to driver.
In a stream, the driver provides the interface between peripheral hardware and the stream. A driver can also be a
pseudo-driver, such as a multiplexor or log driver (see log(7D)), which is not associated with a hardware device.
An active process has an effective user ID and an effective group ID that are used to determine file access permis<hy>
sions (see below). The effective user ID and effective group ID are equal to the process's real user ID and real group
ID, respectively, unless the process or one of its ancestors evolved from a file that had the set-user-ID bit or set-
group-ID bit set (see exec(2)).
Read, write, and execute/search permissions for a file are granted to a process if one or more of the following are
true: <bu> The effective user ID of the process matches the user ID of the owner of the file and the appropriate access bit
of the "owner" portion (0700) of the file mode is set. <bu> The effective user ID of the process does not match the user
ID of the owner of the file, but either the effective group ID or one of the supplementary group IDs of the process
match the group ID of the file and the appropriate access bit of the "group" portion (0070) of the file mode is set. <bu>
The effective user ID of the process does not match the user ID of the owner of the file, and neither the effective
group ID nor any of the supplementary group IDs of the process match the group ID of the file, but the appropriate
access bit of the "other" portion (0007) of the file mode is set. <bu> The read, write, or execute mode bit is not set but
the process has the discretionary file access override privilege for the corresponding mode bit:
{PRIV_FILE_DAC_READ} for the read bit {PRIV_FILE_DAC_WRITE} for the write bit,
{PRIV_FILE_DAC_SEARCH} for the execute bit on directories, and {PRIV_FILE_DAC_EXECUTE} for the
executable bit on plain files.
Otherwise, the corresponding permissions are denied.
A file descriptor is a small integer used to perform I/O on a file. The value of a file descriptor is from 0 to
(NOFILES<mi>1). A process may have no more than NOFILES file descriptors open simultaneously. A file descrip<hy>
tor is returned by calls such as open(2) or pipe(2). The file descriptor is used as an argument by calls such as
read(2), write(2), ioctl(2), and close(2).
Each file descriptor has a corresponding offset maximum. For regular files that were opened without setting the
O_LARGEFILE flag, the offset maximum is 2 Gbyte <mi> 1 byte (2^31 <mi>1 bytes). For regular files that were opened
with the O_LARGEFILE flag set, the offset maximum is 2^63 <mi>1 bytes.
Names consisting of 1 to NAME_MAX characters may be used to name an ordinary file, special file or directory.
These characters may be selected from the set of all character values excluding \0 (null) and the ASCII code for /
(slash).
Note that it is generally unwise to use *, ?, [, or ] as part of file names because of the special meaning attached to
these characters by the shell (see sh(1), csh(1), and ksh(1)). Although permitted, the use of unprintable characters in
file names should be avoided.
A file name is sometimes referred to as a pathname component. The interpretation of a pathname component is de<hy>
pendent on the values of NAME_MAX and _POSIX_NO_TRUNC associated with the path prefix of that compo<hy>
nent. If any pathname component is longer than NAME_MAX and _POSIX_NO_TRUNC is in effect for the path
prefix of that component (see fpathconf(2) and limits.h(3HEAD)), it shall be considered an error condition in that
implementation. Otherwise, the implementation shall use the first NAME_MAX bytes of the pathname component.
Each session that has established a connection with a controlling terminal will distinguish one process group of the
session as the foreground process group of the controlling terminal. This group has certain privileges when access<hy>
ing its controlling terminal that are denied to background process groups.
Maximum number of entries in a struct iovec array.
The braces notation, {LIMIT}, is used to denote a magnitude limitation imposed by the implementation. This indi<hy>
cates a value which may be defined by a header file (without the braces), or the actual value may be obtained at run<hy>
time by a call to the configuration inquiry pathconf(2) with the name argument _PC_LIMIT.
The file mode creation mask of the process used during any create function calls to turn off permission bits in the
mode argument supplied. Bit positions that are set in umask(cmask) are cleared in the mode of the created file.
In a stream, one or more blocks of data or information, with associated STREAMS control structures. Messages can
be of several defined types, which identify the message contents. Messages are the only means of transferring data
and communicating within a stream.
<beginning of page>
In a stream, a linked list of messages awaiting processing by a module or driver.
A message queue identifier (msqid) is a unique positive integer created by a msgget(2) call. Each msqid has a mes<hy>
sage queue and a data structure associated with it. The data structure is referred to as msqid_ds and contains the fol<hy>
lowing members:
 struct ipc_perm msg_perm;
 struct msg *msg_first;
 struct msg *msg_last;
 ulong_t msg_cbytes;
 ulong_t msg_qnum;
 ulong_t msg_qbytes;
 pid_t msg_lspid;
 pid_t msg_lrpid;
 time_t msg_stime;
 time_t msg_rtime;
 time_t msg_ctime;
The following are descriptions of the msqid_ds structure members:
The msg_perm member is an ipc_perm structure that specifies the message operation permission (see below). This
structure includes the following members:
 uid_t cuid; /* creator user id */
 gid_t cgid; /* creator group id */
 uid_t uid; /* user id */
 gid_t gid; /* group id */
 mode_t mode; /* r/w permission */
 ulong_t seq; /* slot usage sequence # */
 key_t key; /* key */
The *msg_first member is a pointer to the first message on the queue.
The *msg_last member is a pointer to the last message on the queue.
The msg_cbytes member is the current number of bytes on the queue.
The msg_qnum member is the number of messages currently on the queue.
The msg_qbytes member is the maximum number of bytes allowed on the queue.
The msg_lspid member is the process ID of the last process that performed a msgsnd() operation.
The msg_lrpid member is the process id of the last process that performed a msgrcv() operation.
The msg_stime member is the time of the last msgsnd() operation.
The msg_rtime member is the time of the last msgrcv() operation.
The msg_ctime member is the time of the last msgctl() operation that changed a member of the above structure.
In the msgctl(2), msgget(2), msgrcv(2), and msgsnd(2) function descriptions, the permission required for an opera<hy>
tion is given as {token}, where token is the type of permission needed, interpreted as follows:
 00400 READ by user
 00200 WRITE by user
 00040 READ by group
 00020 WRITE by group
 00004 READ by others
 00002 WRITE by others
Read and write permissions for a msqid are granted to a process if one or more of the following are true: <bu> The
<beginning of page>
{PRIV_IPC_DAC_READ} or {PRIV_IPC_DAC_WRITE} privilege is present in the effective set. <bu> The effec<hy>
tive user ID of the process matches msg_perm.cuid or msg_perm.uid in the data structure associated with msqid
and the appropriate bit of the "user" portion (0600) of msg_perm.mode is set. <bu> Any group ID in the process cre<hy>
dentials from the set (cr_gid, cr_groups) matches msg_perm.cgid or msg_perm.gid and the appropriate bit of the
"group" portion (060) of msg_perm.mode is set. <bu> The appropriate bit of the "other" portion (006) of
msg_perm.mode is set."
Otherwise, the corresponding permissions are denied.
A module is an entity containing processing routines for input and output data. It always exists in the middle of a
stream, between the stream's head and a driver. A module is the STREAMS counterpart to the commands in a shell
pipeline except that a module contains a pair of functions which allow independent bidirectional (downstream and
upstream) data flow and processing.
A multiplexor is a driver that allows streams associated with several user processes to be connected to a single driv<hy>
er, or several drivers to be connected to a single user process. STREAMS does not provide a general multiplexing
driver, but does provide the facilities for constructing them and for connecting multiplexed configurations of
streams.
An offset maximum is an attribute of an open file description representing the largest value that can be used as a file
offset.
A process group in which the parent of every member in the group is either itself a member of the group, or is not a
member of the process group's session.
A path name is a null-terminated character string starting with an optional slash (/), followed by zero or more direc<hy>
tory names separated by slashes, optionally followed by a file name.
If a path name begins with a slash, the path search begins at the root directory. Otherwise, the search begins from the
current working directory.
A slash by itself names the root directory.
Unless specifically stated otherwise, the null path name is treated as if it named a non-existent file.
Solaris software implements a set of privileges that provide fine-grained control over the actions of processes. The
possession of of a certain privilege allows a process to perform a specific set of restricted operations. Prior to the So<hy>
laris 10 release, a process running with uid 0 was granted all privileges. See privileges(5) for the semantics and the
degree of backward compatibility awarded to processes with an effective uid of 0.
Each process in the system is uniquely identified during its lifetime by a positive integer called a process ID. A
process ID cannot be reused by the system until the process lifetime, process group lifetime, and session lifetime
ends for any process ID, process group ID, and session ID equal to that process ID. There are threads within a
process with thread IDs thread_t and LWPID_t. These threads are not visible to the outside process.
A new process is created by a currently active process (see fork(2)). The parent process ID of a process is the
process ID of its creator.
Having appropriate privilege means having the capability to override system restrictions.
Each process in the system is a member of a process group that is identified by a process group ID. Any process that
is not a process group leader may create a new process group and become its leader. Any process that is not a
process group leader may join an existing process group that shares the same session as the process. A newly creat<hy>
ed process joins the process group of its parent.
A process group leader is a process whose process ID is the same as its process group ID.
Each active process is a member of a process group and is identified by a positive integer called the process group
ID. This ID is the process ID of the group leader. This grouping permits the signaling of related processes (see
kill(2)).
A process lifetime begins when the process is forked and ends after it exits, when its termination has been acknowl<hy>
edged by its parent process. See wait(3C).
A process group lifetime begins when the process group is created by its process group leader, and ends when the
lifetime of the last process in the group ends or when the last process in the group leaves the group.
<beginning of page>
The processors in a system may be divided into subsets, known as processor sets. A process bound to one of these
sets will run only on processors in that set, and the processors in the set will normally run only processes that have
been bound to the set. Each active processor set is identified by a positive integer. See pset_create(2).
In a stream, the message queue in a module or driver containing messages moving upstream.
Each user allowed on the system is identified by a positive integer (0 to MAXUID) called a real user ID.
Each user is also a member of a group. The group is identified by a positive integer called the real group ID.
An active process has a real user ID and real group ID that are set to the real user ID and real group ID, respectively,
of the user responsible for the creation of the process.
Each process has associated with it a concept of a root directory and a current working directory for the purpose of
resolving path name searches. The root directory of a process need not be the root directory of the root file system.
Saved resource limits is an attribute of a process that provides some flexibility in the handling of unrepresentable re<hy>
source limits, as described in the exec family of functions and setrlimit(2).
The saved user ID and saved group ID are the values of the effective user ID and effective group ID just after an ex<hy>
ec of a file whose set user or set group file mode bit has been set (see exec(2)).
A semaphore identifier (semid) is a unique positive integer created by a semget(2) call. Each semid has a set of
semaphores and a data structure associated with it. The data structure is referred to as semid_ds and contains the fol<hy>
lowing members:
 struct ipc_perm sem_perm; /* operation permission struct */
 struct sem *sem_base; /* ptr to first semaphore in set */
 ushort_t sem_nsems; /* number of sems in set */
 time_t sem_otime; /* last operation time */
 time_t sem_ctime; /* last change time */
  /* Times measured in secs since */
  /* 00:00:00 GMT, Jan. 1, 1970 */
The following are descriptions of the semid_ds structure members:
The sem_perm member is an ipc_perm structure that specifies the semaphore operation permission (see below).
This structure includes the following members:
 uid_t uid; /* user id */
 gid_t gid; /* group id */
 uid_t cuid; /* creator user id */
 gid_t cgid; /* creator group id */
 mode_t mode; /* r/a permission */
 ulong_t seq; /* slot usage sequence number */
 key_t key; /* key */
The sem_nsems member is equal to the number of semaphores in the set. Each semaphore in the set is referenced by
a nonnegative integer referred to as a sem_num. sem_num values run sequentially from 0 to the value of
sem_nsems minus 1.
The sem_otime member is the time of the last semop(2) operation.
The sem_ctime member is the time of the last semctl(2) operation that changed a member of the above structure.
A semaphore is a data structure called sem that contains the following members:
 ushort_t semval; /* semaphore value */
 pid_t sempid; /* pid of last operation */
 ushort_t semncnt; /* # awaiting semval > cval */
 ushort_t semzcnt; /* # awaiting semval = 0 */
<beginning of page>
The following are descriptions of the sem structure members:
The semval member is a non-negative integer that is the actual value of the semaphore.
The sempid member is equal to the process ID of the last process that performed a semaphore operation on this
semaphore.
The semncnt member is a count of the number of processes that are currently suspended awaiting this semaphore's
semval to become greater than its current value.
The semzcnt member is a count of the number of processes that are currently suspended awaiting this semaphore's
semval to become 0.
In the semop(2) and semctl(2) function descriptions, the permission required for an operation is given as {token},
where token is the type of permission needed interpreted as follows:
 00400  READ by user
 00200 ALTER by user
 00040 READ by group
 00020 ALTER by group
 00004 READ by others
 00002 ALTER by others
Read and alter permissions for a semid are granted to a process if one or more of the following are true: <bu> The
{PRIV_IPC_DAC_READ} or {PRIV_IPC_DAC_WRITE} privilege is present in the effective set. <bu> The effec<hy>
tive user ID of the process matches sem_perm.cuid or sem_perm.uid in the data structure associated with semid
and the appropriate bit of the "user" portion (0600) of sem_perm.mode is set. <bu> The effective group ID of the
process matches sem_perm.cgid or sem_perm.gid and the appropriate bit of the "group" portion (060) of
sem_perm.mode is set. <bu> The appropriate bit of the "other" portion (06) of sem_perm.mode is set.
Otherwise, the corresponding permissions are denied.
A session is a group of processes identified by a common ID called a session ID, capable of establishing a connec<hy>
tion with a controlling terminal. Any process that is not a process group leader may create a new session and
process group, becoming the session leader of the session and process group leader of the process group. A newly
created process joins the session of its creator.
Each session in the system is uniquely identified during its lifetime by a positive integer called a session ID, the
process ID of its session leader.
A session leader is a process whose session ID is the same as its process and process group ID.
A session lifetime begins when the session is created by its session leader, and ends when the lifetime of the last
process that is a member of the session ends, or when the last process that is a member in the session leaves the ses<hy>
sion.
A shared memory identifier (shmid) is a unique positive integer created by a shmget(2) call. Each shmid has a seg<hy>
ment of memory (referred to as a shared memory segment) and a data structure associated with it. (Note that these
shared memory segments must be explicitly removed by the user after the last reference to them is removed.) The
data structure is referred to as shmid_ds and contains the following members:
 struct ipc_perm shm_perm; /* operation permission struct */
 size_t shm_segsz; /* size of segment */
 struct anon_map *shm_amp; /* ptr to region structure */
 char pad[4]; /* for swap compatibility */
 pid_t shm_lpid; /* pid of last operation */
 pid_t shm_cpid; /* creator pid */
 shmatt_t shm_nattch; /* number of current attaches */
 ulong_t shm_cnattch; /* used only for shminfo */
 time_t shm_atime; /* last attach time */
 time_t shm_dtime; /* last detach time */
 time_t shm_ctime; /* last change time */
  /* Times measured in secs since */
  /* 00:00:00 GMT, Jan. 1, 1970 */
<beginning of page>
The following are descriptions of the shmid_ds structure members:
The shm_perm member is an ipc_perm structure that specifies the shared memory operation permission (see be<hy>
low). This structure includes the following members:
 uid_t cuid; /* creator user id */
 gid_t cgid; /* creator group id */
 uid_t uid; /* user id */
 gid_t gid; /* group id */
 mode_t mode; /* r/w permission */
 ulong_t seq; /* slot usage sequence # */
 key_t key; /* key */
The shm_segsz member specifies the size of the shared memory segment in bytes.
The shm_cpid member is the process ID of the process that created the shared memory identifier.
The shm_lpid member is the process ID of the last process that performed a shmat() or shmdt() operation (see
shmop(2)).
The shm_nattch member is the number of processes that currently have this segment attached.
The shm_atime member is the time of the last shmat() operation (see shmop(2)).
The shm_dtime member is the time of the last shmdt() operation (see shmop(2)).
The shm_ctime member is the time of the last shmctl(2) operation that changed one of the members of the above
structure.
In the shmctl(2), shmat(), and shmdt() (see shmop(2)) function descriptions, the permission required for an opera<hy>
tion is given as {token}, where token is the type of permission needed interpreted as follows:
 00400 READ by user
 00200 WRITE by user
 00040 READ by group
 00020 WRITE by group
 00004 READ by others
 00002 WRITE by others
Read and write permissions for a shmid are granted to a process if one or more of the following are true: <bu> The
{PRIV_IPC_DAC_READ} or {PRIV_IPC_DAC_WRITE} privilege is present in the effective set. <bu> The effec<hy>
tive user ID of the process matches shm_perm.cuid or shm_perm.uid in the data structure associated with shmid
and the appropriate bit of the "user" portion (0600) of shm_perm.mode is set. <bu> The effective group ID of the
process matches shm_perm.cgid or shm_perm.gid and the appropriate bit of the "group" portion (060) of
shm_perm.mode is set. <bu> The appropriate bit of the "other" portion (06) of shm_perm.mode is set.
Otherwise, the corresponding permissions are denied.
The process with ID 0 and the process with ID 1 are special processes referred to as proc0 and proc1; see kill(2).
proc0 is the process scheduler. proc1 is the initialization process (init); proc1 is the ancestor of every other process in
the system and is used to control the process structure.
A set of kernel mechanisms that support the development of network services and data communication drivers. It de<hy>
fines interface standards for character input/output within the kernel and between the kernel and user level processes.
The STREAMS mechanism is composed of utility routines, kernel facilities and a set of data structures.
A stream is a full-duplex data path within the kernel between a user process and driver routines. The primary com<hy>
ponents are a stream head, a driver, and zero or more modules between the stream head and driver. A stream is anal<hy>
ogous to a shell pipeline, except that data flow and processing are bidirectional.
In a stream, the stream head is the end of the stream that provides the interface between the stream and a user
process. The principal functions of the stream head are processing STREAMS-related system calls and passing data
and information between a user process and the stream.
<beginning of page>
In a stream, the direction from driver to stream head.
In a stream, the message queue in a module or driver containing messages moving downstream.
Sun Microsystems, Inc. gratefully acknowledges The Open Group for permission to reproduce portions of its copy<hy>
righted documentation. Original documentation from The Open Group can be obtained online at http://www.open<hy>
group.org/bookstore/.
The Institute of Electrical and Electronics Engineers and The Open Group, have given us permission to reprint por<hy>
tions of their documentation.
In the following statement, the phrase ``this text'' refers to portions of the system documentation.
Portions of this text are reprinted and reproduced in electronic form in the SunOS Reference Manual, from IEEE Std
1003.1, 2004 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The
Open Group Base Specifications Issue 6, Copyright (C) 2001-2004 by the Institute of Electrical and Electronics En<hy>
gineers, Inc and The Open Group. In the event of any discrepancy between these versions and the original IEEE and
The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original
Standard can be obtained online at http://www.opengroup.org/unix/online.html.
This notice shall appear on any product containing this material.
standards(5), threads(5)
