<beginning of page>
mlib_SignalIFFT_3, mlib_SignalIFFT_3_S16_S16_Mod, mlib_SignalIFFT_3_S16C_S16C_Mod, mlib_Sig<hy>
nalIFFT_3_S16_S16C_Mod, mlib_SignalIFFT_3_S16_Mod, mlib_SignalIFFT_3_S16C_Mod, mlib_Sig<hy>
nalIFFT_3_F32_F32, mlib_SignalIFFT_3_F32C_F32C, mlib_SignalIFFT_3_F32_F32C, mlib_SignalIFFT_3_F32,
mlib_SignalIFFT_3_F32C, mlib_SignalIFFT_3_D64_D64, mlib_SignalIFFT_3_D64C_D64C, mlib_Sig<hy>
nalIFFT_3_D64_D64C, mlib_SignalIFFT_3_D64, mlib_SignalIFFT_3_D64C <-> signal Inverse Fast Fourier Trans<hy>
form (IFFT)
cc [ flag... ] file... -lmlib [ library... ]
#include <mlib.h>
mlib_status mlib_SignalIFFT_3_S16_S16_Mod(mlib_s16 *dstr, mlib_s16 *dsti,
 const mlib_s16 *srcr, const mlib_s16 *srci, mlib_s32 order);
mlib_status mlib_SignalIFFT_3_S16C_S16C_Mod(mlib_s16 *dstc,
 const mlib_s16 *srcc,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_S16_S16C_Mod(mlib_s16 *dstr,
 const mlib_s16 *srcc,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_S16_Mod(mlib_s16 *srcdstr,
 mlib_s16 *srcdsti,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_S16C_Mod(mlib_s16 *srcdstc,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_F32_F32(mlib_f32 *dstr,
 mlib_f32 *dsti,
 const mlib_f32 *srcr, const mlib_f32 *srci,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_F32C_F32C(mlib_f32 *dstc,
 const mlib_f32 *srcc,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_F32_F32C(mlib_f32 *dstr,
 const mlib_f32 *srcc,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_F32(mlib_f32 *srcdstr,
 mlib_f32 *srcdsti,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_F32C(mlib_f32 *srcdstc,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_D64_D64(mlib_d64 *dstr,
 mlib_d64 *dsti,
 const mlib_d64 *srcr, const mlib_d64 *srci, mlib_s32 order);
mlib_status mlib_SignalIFFT_3_D64C_D64C(mlib_d64 *dstc,
 const mlib_d64 *srcc,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_D64_D64C(mlib_d64 *dstr,
 const mlib_d64 *srcc,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_D64(mlib_d64 *srcdstr,
 mlib_d64 *srcdsti,
 mlib_s32 order);
mlib_status mlib_SignalIFFT_3_D64C(mlib_d64 *srcdstc, mlib_s32 order);
<beginning of page>
Each of the functions in this group performs Inverse Fast Fourier Transform (IFFT).
The following equation is used for forward FFT:
  1 N-1
 dst[k] = ---- SUM {src[n] * exp(-j2*PI*n*k/N)}
  C1 n=0
and the following equation is used for inverse FFT (IFFT):
  1 N-1
 dst[n] = ---- SUM {src[k] * exp(j2*PI*n*k/N)}
  C2 k=0
where
 k = 0, 1, ..., (N - 1)
 n = 0, 1, ..., (N - 1)
 N = 2**order
The signal FFT/IFFT functions can be categorized into four groups according to the ScaleMode in the function
names in the following form:
 mlib_Signal[FFT|IFFT]_ScaleMode_OutType_InType_OpMode()
 mlib_Signal[FFT|IFFT]_ScaleMode_DataType_OpMode()
The scaling factors C1 and C2 used in the equations are defined as follows: <bu> For ScaleMode = 1, C1 = 1 and C2 =
2**order. <bu> For ScaleMode = 2, C1 = 2**order and C2 = 1. <bu> For ScaleMode = 3, C1 = C2 = 2**(order/2) when
order is even, or C1 = 2**((order+1)/2) and C2 = 2**((order-1)/2) when order is odd. <bu> For ScaleMode = 4, C1
= 2**P and C2 = 2**Q, where P and Q are adaptive scaling factors and are generated by the functions.
For functions with only real parts for the source signal, the imaginary parts are assumed to be all zero. For functions
with only real parts for the destination signal, the imaginary parts are discarded. The functions with only one data
type in their names perform the operation in place.
Each function takes some of the following arguments:
dstr Destination signal array that contains the real parts.
dsti Destination signal array that contains the imaginary parts.
srcr Source signal array that contains the real parts.
srci Source signal array that contains the imaginary parts.
dstc Complex destination signal array. dstc[2*i] contains the real parts, and dstc[2*i+1] contains the imaginary
parts.
srcc Complex source signal array. srcc[2*i] contains the real parts, and srcc[2*i+1] contains the imaginary parts.
srcdstr Source and destination signal array that contains the real parts.
srcdsti Source and destination signal array that contains the imaginary parts.
<beginning of page>
srcdstc Complex source and destination signal array. srcdstc[2*i] contains the real parts, and srcdstc[2*i+1] con<hy>
tains the imaginary parts.
order Order of the transformation. The base-2 logarithm of the number of data samples.
The function returns MLIB_SUCCESS if successful. Otherwise it returns MLIB_FAILURE.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
mlib_SignalFFT_1(3MLIB), mlib_SignalFFT_2(3MLIB), mlib_SignalFFT_3(3MLIB), mlib_Sig<hy>
nalFFT_4(3MLIB), mlib_SignalIFFT_1(3MLIB), mlib_SignalIFFT_2(3MLIB), mlib_SignalIFFT_4(3MLIB),
attributes(5)
