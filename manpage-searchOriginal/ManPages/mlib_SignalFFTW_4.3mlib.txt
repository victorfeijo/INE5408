<beginning of page>
mlib_SignalFFTW_4, mlib_SignalFFTW_4_S16_S16, mlib_SignalFFTW_4_S16C_S16C, mlib_Sig<hy>
nalFFTW_4_S16C_S16, mlib_SignalFFTW_4_S16, mlib_SignalFFTW_4_S16C <-> signal Fast Fourier Transform
with windowing (FFTW)
cc [ flag... ] file... -lmlib [ library... ]
#include <mlib.h>
mlib_status mlib_SignalFFTW_4_S16_S16(mlib_s16 *dstr, mlib_s16 *dsti,
 const mlib_s16 *srcr, const mlib_s16 *srci, const mlib_s16 *window,
 mlib_s32 order, mlib_s32 *scale);
mlib_status mlib_SignalFFTW_4_S16C_S16C(mlib_s16 *dstc,
 const mlib_s16 *srcc,const mlib_s16 *window, mlib_s32 order,
 mlib_s32 *scale);
mlib_status mlib_SignalFFTW_4_S16C_S16(mlib_s16 *dstc,
 const mlib_s16 *srcr,const mlib_s16 *window, mlib_s32 order,
 mlib_s32 *scale);
mlib_status mlib_SignalFFTW_4_S16(mlib_s16 *srcdstr,
 mlib_s16 *srcdsti,const mlib_s16 *window, mlib_s32 order,
 mlib_s32 *scale);
mlib_status mlib_SignalFFTW_4_S16C(mlib_s16 *srcdstc,
 const mlib_s16 *window,mlib_s32 order, mlib_s32 *scale);
Each of the functions in this group performs Fast Fourier Transform with windowing (FFTW).
The FFTW functions use the following equation:
  1 N-1
 dst[k] = ---- SUM {src[n] * window[n] * exp(-j2*PI*n*k/N)}
  C1 n=0
and the IFFTW functions use the following equation:
  1 N-1
 dst[n] = ---- SUM {src[k] * window[k] * exp(j2*PI*n*k/N)}
  C2 k=0
where
 k = 0, 1, ..., (N - 1)
 n = 0, 1, ..., (N - 1)
 N = 2**order
The signal FFTW/IFFTW functions can be categorized into four groups according to the ScaleMode in the function
names in the following form:
 mlib_Signal[FFTW|IFFTW]_ScaleMode_OutType_InType_OpMode()
 mlib_Signal[FFTW|IFFTW]_ScaleMode_DataType_OpMode()
The scaling factors C1 and C2 used in the equations are defined as follows: <bu> For ScaleMode = 1, C1 = 1 and C2 =
2**order. <bu> For ScaleMode = 2, C1 = 2**order and C2 = 1. <bu> For ScaleMode = 3, C1 = C2 = 2**(order/2) when
order is even, or C1 = 2**((order+1)/2) and C2 = 2**((order-1)/2) when order is odd. <bu> For ScaleMode = 4, C1
= 2**P and C2 = 2**Q, where P and Q are adaptive scaling factors and are generated by the functions.
For functions with only real parts for the source signal, the imaginary parts are assumed to be all zero. For functions
with only real parts for the destination signal, the imaginary parts are discarded. The functions with only one data
type in their names perform the operation in place.
Each function takes some of the following arguments:
<beginning of page>
dstr Destination signal array that contains the real parts.
dsti Destination signal array that contains the imaginary parts.
srcr Source signal array that contains the real parts.
srci Source signal array that contains the imaginary parts.
dstc Complex destination signal array. dstc[2*i] contains the real parts, and dstc[2*i+1] contains the imaginary
parts.
srcc Complex source signal array. srcc[2*i] contains the real parts, and srcc[2*i+1] contains the imaginary parts.
srcdstr Source and destination signal array that contains the real parts.
srcdsti Source and destination signal array that contains the imaginary parts.
srcdstc Complex source and destination signal array. srcdstc[2*i] contains the real parts, and srcdstc[2*i+1] con<hy>
tains the imaginary parts.
window Window coefficient array with 2**order real elements. The window coefficients are in Q15 format for the
S16 data type, or in float format for the F32 data type.
order Order of the transformation. The base-2 logarithm of the number of data samples.
scale Adaptive scaling factor.
Each function returns MLIB_SUCCESS if successful. Otherwise it returns MLIB_FAILURE.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
mlib_SignalFFTW_1(3MLIB), mlib_SignalFFTW_2(3MLIB), mlib_SignalFFTW_3(3MLIB), mlib_Sig<hy>
nalIFFTW_1(3MLIB), mlib_SignalIFFTW_2(3MLIB), mlib_SignalIFFTW_3(3MLIB), mlib_Sig<hy>
nalIFFTW_4(3MLIB), attributes(5)
