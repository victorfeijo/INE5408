<beginning of page>
vsinpi_, vsinpif_ <-> vector sinpi functions
cc [ flag... ] file... -lmvec [ library... ]
void vsinpi_(int *n, double * restrict x, int *stridex,
 double * restrict y, int *stridey);
void vsinpif_(int *n, float * restrict x, int *stridex,
 float * restrict y, int *stridey);
These functions evaluate the function sinpi(x), defined by sinpi(x) = sin(<*p>  * x), for an entire vector of values at
once. The first parameter specifies the number of values to compute. Subsequent parameters specify the argument
and result vectors. Each vector is described by a pointer to the first element and a stride, which is the increment be<hy>
tween successive elements.
Specifically, vsinpi_(n, x, sx, y, sy) computes y[i * *sy] = sinpi(x[i * *sx]) for each i = 0, 1, ..., *n - 1. The vsinpif_()
function performs the same computation for single precision data.
Non-exceptional results are accurate to within a unit in the last place.
The element count *n must be greater than zero. The strides for the argument and result arrays can be arbitrary inte<hy>
gers, but the arrays themselves must not be the same or overlap. A zero stride effectively collapses an entire vector
into a single element. A negative stride causes a vector to be accessed in descending memory order, but note that the
corresponding pointer must still point to the first element of the vector to be used; if the stride is negative, this will
be the highest-addressed element in memory. This convention differs from the Level 1 BLAS, in which array param<hy>
eters always refer to the lowest-addressed element in memory even when negative increments are used.
These functions assume that the default round-to-nearest rounding direction mode is in effect. On x86, these func<hy>
tions also assume that the default round-to-64-bit rounding precision mode is in effect. The result of calling a vector
function with a non-default rounding mode in effect is undefined.
These functions handle special cases and exceptions in the spirit of IEEE 754. In particular, <bu> sinpi(NaN) is NaN, <bu>
sinpi(<+->0) is <+->0, <bu> sinpi(<+->Inf) is NaN, and an invalid operation exception is raised.
An application wanting to check for exceptions should call feclearexcept(FE_ALL_EXCEPT) before calling these
functions. On return, if fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDER<hy>
FLOW) is non-zero, an exception has been raised. The application can then examine the result or argument vectors
for exceptional values. Some vector functions can raise the inexact exception even if all elements of the argument ar<hy>
ray are such that the numerical results are exact.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
feclearexcept(3M), fetestexcept(3M), attributes(5)
