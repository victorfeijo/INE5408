<beginning of page>
yacc <-> yet another compiler-compiler
yacc [-dltVv] [-b file_prefix] [-Q [y | n]]
 [-P parser] [-p sym_prefix] file
The yacc command converts a context-free grammar into a set of tables for a simple automaton that executes an
LALR(1) parsing algorithm. The grammar can be ambiguous. Specified precedence rules are used to break ambigui<hy>
ties.
The output file, y.tab.c, must be compiled by the C compiler to produce a function yyparse(). This program must be
loaded with the lexical analyzer program, yylex(), as well as main() and yyerror(), an error handling routine. These
routines must be supplied by the user. The lex(1) command is useful for creating lexical analyzers usable by yacc.
The following options are supported:
-b file_prefix Uses file_prefix instead of y as the prefix for all output files. The code file y.tab.c, the header file
y.tab.h (created when -d is specified), and the description file y.output (created when -v is specified), is changed to
file_prefix.tab.c, file_prefix.tab.h, and file_prefix.output, respectively.
-d Generates the file y.tab.h with the #define statements that associate the yacc user-assigned "token codes" with the
user-declared "token names". This association allows source files other than y.tab.c to access the token codes.
-l Specifies that the code produced in y.tab.c does not contain any #line constructs. This option should only be used
after the grammar and the associated actions are fully debugged.
-p sym_prefix Uses sym_prefix instead of yy as the prefix for all external names produced by yacc. The names affect<hy>
ed include the functions yyparse(), yylex() and yyerror(), and the variables yylval, yychar and yydebug. (In the re<hy>
mainder of this section, the six symbols cited are referenced using their default names only as a notational con<hy>
venience.) Local names can also be affected by the -p option. However, the -p option does not affect #define sym<hy>
bols generated by yacc.
-P parser Allows you to specify the parser of your choice instead of /usr/share/lib/ccs/yaccpar. For example, you
can specify:
 example% yacc -P ~/myparser parser.y
-Q[y|n] The -Qy option puts the version stamping information in y.tab.c. This allows you to know what version of
yacc built the file. The -Qn option (the default) writes no version information.
-t Compiles runtime debugging code by default. Runtime debugging code is always generated in y.tab.c under con<hy>
ditional compilation control. By default, this code is not included when y.tab.c is compiled. Whether or not the -t
option is used, the runtime debugging code is under the control of YYDEBUG , a preprocessor symbol. If YYDE<hy>
BUG has a non-zero value, then the debugging code is included. If its value is 0, then the code is not included. The
size and execution time of a program produced without the runtime debugging code is smaller and slightly faster.
-v Prepares the file y.output, which contains a description of the parsing tables and a report on conflicts generated
by ambiguities in the grammar.
-V Prints on the standard error output the version information for yacc.
The following operand is required:
file A path name of a file containing instructions for which a parser is to be created.
Example 1 Accessing the yacc Library
<beginning of page>
Access to the yacc library is obtained with library search operands to cc. To use the yacc library main:
 example% cc y.tab.c -ly
Both the lex library and the yacc library contain main. To access the yacc main:
 example% cc y.tab.c lex.yy.c -ly -ll
This ensures that the yacc library is searched first, so that its main is used.
The historical yacc libraries have contained two simple functions that are normally coded by the application pro<hy>
grammer. These library functions are similar to the following code:
 #include <locale.h>
 int main(void)
 {
  extern int yyparse();
  setlocale(LC_ALL, "");
  /* If the following parser is one created by lex, the
  application must be careful to ensure that LC_CTYPE
  and LC_COLLATE are set to the POSIX locale. */
  (void) yyparse();
  return (0);
 }
 #include <stdio.h>
 int yyerror(const char *msg)
 {
  (void) fprintf(stderr, "%s\n", msg);
  return (0);
 }
See environ(5) for descriptions of the following environment variables that affect the execution of yacc: LANG,
LC_ALL, LC_CTYPE, LC_MESSAGES, and NLSPATH.
yacc can handle characters from EUC primary and supplementary codesets as one-token symbols. EUC codes can
only be single character quoted terminal symbols. yacc expects yylex() to return a wide character (wchar_t) value
for these one-token symbols.
The following exit values are returned:
0 Successful completion.
>0 An error occurred.
y.output state transitions of the generated parser
y.tab.c source code of the generated parser
<beginning of page>
y.tab.h header file for the generated parser
yacc.acts temporary file
yacc.debug temporary file
yacc.tmp temporary file
yaccpar parser prototype for C programs
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ AvailabilitySUN<hy>
Wbtool _ Interface StabilityCommitted _ StandardSee standards(5).
lex(1), attributes(5), environ(5), standards(5)
The number of reduce-reduce and shift-reduce conflicts is reported on the standard error output. A more detailed re<hy>
port is found in the y.output file. Similarly, if some rules are not reachable from the start symbol, this instance is al<hy>
so reported.
Because file names are fixed, at most one yacc process can be active in a given directory at a given time.
Users are encouraged to avoid using $ as part of any identifier name.
