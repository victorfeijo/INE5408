<beginning of page>
mlib_SignalFFT_4, mlib_SignalFFT_4_S16_S16, mlib_SignalFFT_4_S16C_S16C, mlib_SignalFFT_4_S16C_S16,
mlib_SignalFFT_4_S16, mlib_SignalFFT_4_S16C <-> signal Fast Fourier Transform (FFT)
cc [ flag... ] file... -lmlib [ library... ]
#include <mlib.h>
mlib_status mlib_SignalFFT_4_S16_S16(mlib_s16 *dstr, mlib_s16 *dsti,
 const mlib_s16 *srcr, const mlib_s16 *srci, mlib_s32 order,
 mlib_s32 *scale);
mlib_status mlib_SignalFFT_4_S16C_S16C(mlib_s16 *dstc,
 const mlib_s16 *srcc,
 mlib_s32 order, mlib_s32 *scale);
mlib_status mlib_SignalFFT_4_S16C_S16(mlib_s16 *dstc,
 const mlib_s16 *srcr,
 mlib_s32 order, mlib_s32 *scale);
mlib_status mlib_SignalFFT_4_S16(mlib_s16 *srcdstr, mlib_s16 *srcdsti,
 mlib_s32 order, mlib_s32 *scale);
mlib_status mlib_SignalFFT_4_S16C(mlib_s16 *srcdstc, mlib_s32 order,
 mlib_s32 *scale);
Each of the functions in this group performs Fast Fourier Transform (FFT).
The following equation is used for forward FFT:
  1 N-1
 dst[k] = ---- SUM {src[n] * exp(-j2*PI*n*k/N)}
  C1 n=0
and the following equation is used for inverse FFT (IFFT):
  1 N-1
 dst[n] = ---- SUM {src[k] * exp(j2*PI*n*k/N)}
  C2 k=0
where
 k = 0, 1, ..., (N - 1)
 n = 0, 1, ..., (N - 1)
 N = 2**order
The signal FFT/IFFT functions can be categorized into four groups according to the ScaleMode in the function
names in the following form:
 mlib_Signal[FFT|IFFT]_ScaleMode_OutType_InType_OpMode()
 mlib_Signal[FFT|IFFT]_ScaleMode_DataType_OpMode()
The scaling factors C1 and C2 used in the equations are defined as follows: <bu> For ScaleMode = 1, C1 = 1 and C2 =
2**order. <bu> For ScaleMode = 2, C1 = 2**order and C2 = 1. <bu> For ScaleMode = 3, C1 = C2 = 2**(order/2) when
order is even, or C1 = 2**((order+1)/2) and C2 = 2**((order-1)/2) when order is odd. <bu> For ScaleMode = 4, C1
= 2**P and C2 = 2**Q, where P and Q are adaptive scaling factors and are generated by the functions.
For functions with only real parts for the source signal, the imaginary parts are assumed to be all zero. For functions
with only real parts for the destination signal, the imaginary parts are discarded. The functions with only one data
type in their names perform the operation in place.
Each function takes some of the following arguments:
<beginning of page>
dstr Destination signal array that contains the real parts.
dsti Destination signal array that contains the imaginary parts.
srcr Source signal array that contains the real parts.
srci Source signal array that contains the imaginary parts.
dstc Complex destination signal array. dstc[2*i] contains the real parts, and dstc[2*i+1] contains the imaginary
parts.
srcc Complex source signal array. srcc[2*i] contains the real parts, and srcc[2*i+1] contains the imaginary parts.
srcdstr Source and destination signal array that contains the real parts.
srcdsti Source and destination signal array that contains the imaginary parts.
srcdstc Complex source and destination signal array. srcdstc[2*i] contains the real parts, and srcdstc[2*i+1] con<hy>
tains the imaginary parts.
order Order of the transformation. The base-2 logarithm of the number of data samples.
scale Adaptive scaling factor.
The function returns MLIB_SUCCESS if successful. Otherwise it returns MLIB_FAILURE.
See attributes(5) for descriptions of the following attributes:
tab() box; cw(2.75i) |cw(2.75i) lw(2.75i) |lw(2.75i) ATTRIBUTE TYPEATTRIBUTE VALUE _ Interface Stability<hy>
Committed _ MT-LevelMT-Safe
mlib_SignalFFT_1(3MLIB), mlib_SignalFFT_2(3MLIB), mlib_SignalFFT_3(3MLIB), mlib_Sig<hy>
nalIFFT_1(3MLIB), mlib_SignalIFFT_2(3MLIB), mlib_SignalIFFT_3(3MLIB), mlib_SignalIFFT_4(3MLIB),
attributes(5)
